<!-- https://ourcodeworld.com/articles/read/49/draw-points-on-a-canvas-with-javascript-html5 -->
<html>
<head>
	
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
<script src="matrix.js"></script>
<script type="text/javascript"></script>

<!-- <script type="text/javascript" src="box.js"></script> -->
<script>
	function load() {
		$("#canvas").click(function( e ) { getPosition(e); });
		drawAxes();
	}

	var pointSize = 5;
	var arrayForMatrix = new Array()

	// When the user clicks on div, open the popup
	function myFunction() {
	  var popup = document.getElementById("myPopup");
	  popup.classList.toggle("show");
	}

	function getPosition(event){
	 	var rect = canvas.getBoundingClientRect();
	 	var x = event.clientX - rect.left;
	 	var y = event.clientY - rect.top;
		var color = "#0ECB48"; /* Green */
		var color_name = "green"
		var color_num = 0

		if (event.shiftKey) {
			color = "#ff2626"; /* Red */
			color_name = "red"
			color_num = 1
		}
		arrayForMatrix.push(x,y,color_num)
		
	 	drawCoordinates(x,y,color);
	}

	function drawCoordinates(x,y,color){	
		var ctx = document.getElementById("canvas").getContext("2d");


		ctx.fillStyle = color; // Red color

		ctx.beginPath();
		ctx.arc(x, y, pointSize, 0, Math.PI * 2, true);
		ctx.fill();
	}

	var canvas_width  = 760
	var canvas_height = 400

	var x_drawx = 50
	var y_drawx = canvas_height/2.0

	var x_drawy = canvas_width /2.0
	var y_drawy = x_drawx

	var pad = 5
	var unitDistance = 20

	function drawAxes() {
		var c = document.getElementById("canvas")
		var ctx = c.getContext("2d")

		// DRAW GRID
		var space = 0;
		for (var i = 0; i < 19; i++) {
			ctx.beginPath()
			ctx.strokeStyle = "#e8dcca"
			ctx.moveTo(x_drawy + space,                0)
			ctx.lineTo(x_drawy + space, canvas_height)
			ctx.stroke()

			ctx.beginPath()
			ctx.moveTo(x_drawy - space,                0)
			ctx.lineTo(x_drawy - space, canvas_height)
			ctx.stroke()

			ctx.beginPath()
			ctx.moveTo(           0, y_drawx + space)
			ctx.lineTo(canvas_width, y_drawx + space)
			ctx.stroke()

			ctx.beginPath()
			ctx.moveTo(           0, y_drawx - space)
			ctx.lineTo(canvas_width, y_drawx - space)
			ctx.stroke()
			space += unitDistance;
		}


		// DRAW X-AXIS
		// draw x-axis line
		ctx.beginPath()
		ctx.strokeStyle = "black"
		ctx.moveTo(               x_drawx, y_drawx)
		ctx.lineTo(canvas_width - x_drawx, y_drawx)
		ctx.stroke()

		// triangle left
		ctx.beginPath()
		ctx.moveTo(x_drawx     , y_drawx     )
		ctx.lineTo(x_drawx +pad, y_drawx +pad)
		ctx.lineTo(x_drawx +pad, y_drawx -pad)
		ctx.fillStyle = "black"
		ctx.fill()

		// triangle right
		ctx.beginPath()
		ctx.moveTo(canvas_width - x_drawx     , y_drawx     )
		ctx.lineTo(canvas_width - x_drawx -pad, y_drawx +pad)
		ctx.lineTo(canvas_width - x_drawx -pad, y_drawx -pad)
		ctx.fill()

		// DRAW Y-AXIS
		// draw y-axis line
		ctx.beginPath()
		ctx.moveTo(x_drawy,                 y_drawy)
		ctx.lineTo(x_drawy, canvas_height - y_drawy)
		ctx.stroke()

		// triangle up
		ctx.beginPath();
		ctx.moveTo(x_drawy     , y_drawy     );
		ctx.lineTo(x_drawy -pad, y_drawy +pad);
		ctx.lineTo(x_drawy +pad, y_drawy +pad);
		ctx.fill();

		// triangle down
		ctx.beginPath();
		ctx.moveTo(x_drawy     , canvas_height - y_drawy     );
		ctx.lineTo(x_drawy -pad, canvas_height - y_drawy -pad);
		ctx.lineTo(x_drawy +pad, canvas_height - y_drawy -pad);
		ctx.fill();
	}
	
	
	function resetBtn() {
		// remove coordinates print1-out
		$("pre").empty();
		
		// remove "under construction" text
		$("#result").empty();
		
		// reset arrayForMatrix
		arrayForMatrix = new Array()
		
		// reset grid
		const context = canvas.getContext('2d');
		context.clearRect(0, 0, canvas.width, canvas.height);
		drawAxes();
	}
	
	// Coordinate system switching functions
	function arrayXPhysicalToLogicalCoordSys( arrayXPhys ) {
		var arrayXLogical = new Array()
		for (var i = 0; i < arrayXPhys.length; i++) {
			arrayXLogical.push((arrayXPhys[i] - canvas_width/2)/unitDistance)
		}
		return arrayXLogical
	}
	
	function arrayYPhysicalToLogicalCoordSys( arrayYPhys ) {
		var arrayYLogical = new Array()
		for (var i = 0; i < arrayYPhys.length; i++) {
			arrayYLogical.push(((arrayYPhys[i] - canvas_height/2)/unitDistance) *(-1))
		}
		return arrayYLogical
	}
	
	function arrayXLogicalToPhysicalCoordSys( arrayXLogical ) {
		var arrayXPhys = new Array()
		for (var i = 0; i < arrayXLogical.length; i++) {
			arrayXPhys.push((arrayXLogical[i] *unitDistance + canvas_width/2))
		}
		return arrayXPhys
	}
	
	function arrayYLogicalToPhysicalCoordSys( arrayYLogical ) {
		var arrayYPhys = new Array()
		for (var i = 0; i < arrayYLogical.length; i++) {
			arrayYPhys.push((arrayYLogical[i] *unitDistance *(-1) + canvas_height/2) )
		}
		return arrayYPhys
	}
	
	function getPhysX( x ) {
		return x *unitDistance + canvas_width/2
	}
	
	function getPhysY( y ) {
		return y *unitDistance *(-1) + canvas_height/2
	}
	
	function getLogX( x ) {
		return (x - canvas_width/2)/unitDistance
	}
	
	function getLogY( y ) {
		return ((y - canvas_height/2)/unitDistance) *(-1)
	}
	
	function getMinLogX() {
		return getLogX(0)
	}
	
	function getMaxLogX() {
		return getLogX(canvas_width)
	}
	
	function getMinLogY() {
		return getLogY(canvas_height)
	}
	
	function getMaxLogY() {
		return getLogY(0)
	}
	
	/* Global variables for ML functions */
	var isGreen = false;
	var arrayGreenX = new Array();
	var arrayGreenY = new Array();
	
	var isRed = false;
	var arrayRedX = new Array();
	var arrayRedY = new Array();
	
	
	/* ML functions */
	
	/* Linear Regression */
	// Y = XA + E
	// solving for A: A = (X^T X)^(-1) X^T Y
	// Make sure cases where pseudo-inverse won't work are accounted for
	// when inputs are identical, should return a line with slope zero
	function linearRegression() {
		document.getElementById("result").innerHTML = "Step-by-step explanation using plotted datapoints coming soon!";
		resetVariables()
		
		// break array of datapoints into separate arrays corresponding to their color and variable
		breakIntoSeparateArrays(arrayForMatrix)
		
		// if data for a color exists, build its regression line
		if (isGreen) {
			var color = "green"
			buildLine(arrayGreenX, arrayGreenY, color)
		}
		
		if (isRed) {
			var color = "red"
			buildLine(arrayRedX, arrayRedY, color)
		}
		
		// linear regression functions
		function buildLine( arrayX, arrayY, color ) {
			
			// test physical-to-logical coordinates for arrays
			var logicalArrayX = arrayXPhysicalToLogicalCoordSys(arrayX)
			var logicalArrayY = arrayYPhysicalToLogicalCoordSys(arrayY)
			
			
			// build physical matrices
			var MatrixX = createMatrixX(arrayX);
			var MatrixY = createMatrixY(arrayY);
			
			
			// build logical matrices
			var logicalMatrixX = createMatrixX(logicalArrayX);
			var logicalMatrixY = createMatrixY(logicalArrayY);
			
			var A = createMatrixA(logicalMatrixX, logicalMatrixY)
			var minLogX = getMinLogX()
			var maxLogX = getMaxLogX()
			var minLogY = getMinLogY()
			var maxLogY = getMaxLogY()
			

				// logical 
				var m = A[[1,0]]
				if (isNaN(m)) {
					m = 0
				}
				
				var b = A[[0,0]]
				if (isNaN(b)) {
					var addedRowsMatrixX = logicalMatrixY.transpose().multiply(Matrix_ones_vector(logicalMatrixY))
					b = addedRowsMatrixX[[0,0]]/logicalMatrixY.length
				}
				// create line
				var xStep = (getMaxLogX() - getMinLogX())/canvas_width
				var first = true
				var c = document.getElementById("canvas")
				var ctx = c.getContext("2d")
				ctx.beginPath()
				ctx.strokeStyle = color
				for (var x = getMinLogX(); x <= getMaxLogX(); x+= xStep) {
					var y = linearFunction(x, m, b)
					if (first) {
						ctx.moveTo(getPhysX(x), getPhysY(y))
						first = false
					}
					else {
						ctx.lineTo(getPhysX(x), getPhysY(y))
					}
				}
				ctx.stroke()
			
			function linearFunction( x, m, b ) {
				return m *x + b
			}
		}
		
		// all x entries are the same and at least one y entry is different
		function isInfSlope( arrayX, arrayY, infSlope ) {
			var xEntriesTheSame = true
			var yEntriesTheSame = true
			for (var i = 1; i < arrayX.length; i++) {
				// using floor to undo changed input for accommodating non-invertibles
				if (Math.floor(arrayX[0]) != Math.floor(arrayX[i])) {
					xEntriesTheSame = false
				}
				if (Math.floor(arrayY[0]) != Math.floor(arrayY[i])) {
					yEntriesTheSame = false
				}
			}
			
			if (xEntriesTheSame && yEntriesTheSame == false) {
				infSlope = true
			}
			return infSlope
		}
		
		function createMatrixX( arrayX ) {
			var X = new Matrix(arrayX.length, 1, arrayX);
			X = X.insert_columns(0, 1);
			
			return X;
		}
		
		function createMatrixY( arrayY ) {
			var Y = new Matrix(arrayY.length, 1, arrayY);
			
			return Y;
		}
		
		// find matrix A, a 2x1 made up of b (A[[0,0]]) and m (A[[1,0]])
		// A = (X^T X)^-1 X^T Y
		function createMatrixA( MatrixX, MatrixY ) {
			var XTXinverse = Matrix_inverse(MatrixX.transpose().multiply(MatrixX))
			var XTY        = MatrixX.transpose().multiply(MatrixY)
			var A = XTXinverse.multiply(XTY)
			
			return A
		}
	}
	
	function kernelRegression() {
		document.getElementById("result").innerHTML = "Step-by-step explanation using plotted datapoints with polynomial input selection coming soon!";
		var polynomialDegree = 3
		RegressionWithDegree(polynomialDegree)
		
		function RegressionWithDegree( polynomialDegree ) {
			
			resetVariables()

			// break array of datapoints into separate arrays corresponding to their color and variable
			breakIntoSeparateArrays(arrayForMatrix)

			// if data for a color exists, build its regression line
			if (isGreen) {
				var color = "green"
				
				/* The "Over-fitter" */
				// test polynomial degree being set based on number of data points
				//polynomialDegree = arrayGreenX.length - 1
				//buildRegressionLine(arrayGreenX, arrayGreenY, color, polynomialDegree)
				
				/* The Best Fit */
				// fit to a line for 2 or less datapoints
				if (arrayGreenX.length <= 2) {
					buildRegressionLine(arrayGreenX, arrayGreenY, color, 1)
				} else if (arrayGreenX.length <= 5) {
					buildRegressionLine(arrayGreenX, arrayGreenY, color, 2)
				} else if (arrayGreenX.length <= 10) {
					buildRegressionLine(arrayGreenX, arrayGreenY, color, 3)
				} else {
					buildRegressionLine(arrayGreenX, arrayGreenY, color, 4)
				}
			}

			if (isRed) {
				var color = "red"
				if (arrayRedX.length <= 2) {
					buildRegressionLine(arrayRedX, arrayRedY, color, 1)
				} else if (arrayRedX.length <= 5) {
					buildRegressionLine(arrayRedX, arrayRedY, color, 2)
				} else if (arrayRedX.length <= 10) {
					buildRegressionLine(arrayRedX, arrayRedY, color, 3)
				} else {
					buildRegressionLine(arrayRedX, arrayRedY, color, 4)
				}
			}
			
			// kernel regression functions
			function buildRegressionLine( arrayX, arrayY, color, polynomialDegree ) {

				// test physical-to-logical coordinates for arrays
				var logicalArrayX = arrayXPhysicalToLogicalCoordSys(arrayX)

				var logicalArrayY = arrayYPhysicalToLogicalCoordSys(arrayY)

				// build physical matrices
				var MatrixX = createMatrixX(arrayX);
				var MatrixY = createMatrixY(arrayY);

				// build logical matrices
				var logicalMatrixX = createMatrixX(logicalArrayX, polynomialDegree);
				var logicalMatrixY = createMatrixY(logicalArrayY);
				
				
				var A = createMatrixA(logicalMatrixX, logicalMatrixY)
				var minLogX = getMinLogX()
				var maxLogX = getMaxLogX()
				var minLogY = getMinLogY()
				var maxLogY = getMaxLogY()
				
				
				// create line
				var xStep = (getMaxLogX() - getMinLogX())/canvas_width
				var first = true
				var c = document.getElementById("canvas")
				var ctx = c.getContext("2d")
				ctx.beginPath()
				ctx.strokeStyle = color
				for (var x = getMinLogX(); x <= getMaxLogX(); x+= xStep) {
					var y = polynomialFunction(x, A)
					if (first) {
						ctx.moveTo(getPhysX(x), getPhysY(y))
						first = false
					}
					else {
						ctx.lineTo(getPhysX(x), getPhysY(y))
					}
				}
				ctx.stroke()

				function polynomialFunction( x, A ) {
					var polynomialF = 0
					for (var i = 0; i < A.length; i++) {
						
						//if (A.length == 1 && )
						if (i == 0 && isNaN(A[[0,0]])) {
							// b equals the average of y array inputs
							var addedRowsMatrixY = logicalMatrixY.transpose().multiply(Matrix_ones_vector(logicalMatrixY))
							A[[0,0]] = addedRowsMatrixY[[0,0]]/logicalMatrixY.length
						}
						if (i >= 1 && isNaN(A[[i,0]])) {
							A[[i,0]] = 0
						}
						
						polynomialF += ((x **(i)) * A[[i,0]])
					}
					// returns a_0 + x*a_1 + x^2*a_2 + ... x^n*a_n 
					return polynomialF
				}
			}

			// all x entries are the same and at least one y entry is different
			function isInfSlope( arrayX, arrayY, infSlope ) {
				var xEntriesTheSame = true
				var yEntriesTheSame = true
				for (var i = 1; i < arrayX.length; i++) {
					// using floor to undo changed input for accommodating non-invertibles
					if (Math.floor(arrayX[0]) != Math.floor(arrayX[i])) {
						xEntriesTheSame = false
					}
					if (Math.floor(arrayY[0]) != Math.floor(arrayY[i])) {
						yEntriesTheSame = false
					}
				}

				if (xEntriesTheSame && yEntriesTheSame == false) {
					infSlope = true
				}
				return infSlope
			}

			// [1, x, x^2, ..., x^n]
			// would need to feed in the degree of the polynomial
			function createMatrixX( arrayX, polynomialDegree ) {
				var X = new Matrix(arrayX.length, 1, arrayX);
				var polynomialArray
				for (var i = 1; i < polynomialDegree; i++) {
					polynomialArray =  arrayX.map(x => x **(i+1))
					X = X.insert_columns(X.numColumns, polynomialArray)
					//pop inserted column
				}
				X = X.insert_columns(0, 1);
				
				return X;
			}

			function createMatrixY( arrayY ) {
				var Y = new Matrix(arrayY.length, 1, arrayY);

				return Y;
			}

			// find matrix A, a 2x1 made up of b (A[[0,0]]) and m (A[[1,0]])
			// A = (X^T X)^-1 X^T Y
			function createMatrixA( MatrixX, MatrixY ) {
				var XTXinverse = Matrix_inverse(MatrixX.transpose().multiply(MatrixX))
				var XTY        = MatrixX.transpose().multiply(MatrixY)
				var A = XTXinverse.multiply(XTY)

				return A
			}
		}
	}
	
	function kNearest() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function kMeans() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function decisionTrees() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function randomForest() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function standardSVM() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function multiSVM() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function neuralNetwork() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function logisticRegression() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function naiveBayes() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	function gaussianMixtureModel() {
		document.getElementById("result").innerHTML = "Under construction! Please try again soon!";
		var newMatrix = new Matrix(arrayForMatrix.length/3, 3, arrayForMatrix);
	}
	
	// functions used by multiple ML functions
	function resetVariables() {
		isGreen = false;
		arrayGreenX = new Array();
		arrayGreenY = new Array();
        
		isRed = false;
		arrayRedX = new Array();
		arrayRedY = new Array();
	}
	
	function breakIntoSeparateArrays( arrayForMatrix ) {
		for (var i = 2; i < arrayForMatrix.length; i+=3) {
			if (arrayForMatrix[i] == 0) {
				isGreen = true;
				arrayGreenX.push(arrayForMatrix[i -2]);
				arrayGreenY.push(arrayForMatrix[i -1]);
			}
			if (arrayForMatrix[i] == 1) {
				isRed = true;
				arrayRedX.push(arrayForMatrix[i -2]);
				arrayRedY.push(arrayForMatrix[i -1]);
			} 
		}
	}
	
	function breakIntoSeparateArrays( arrayForMatrix ) {
		for (var i = 2; i < arrayForMatrix.length; i+=3) {
			if (arrayForMatrix[i] == 0) {
				isGreen = true;
				arrayGreenX.push(arrayForMatrix[i -2]);
				arrayGreenY.push(arrayForMatrix[i -1]);
			}
			if (arrayForMatrix[i] == 1) {
				isRed = true;
				arrayRedX.push(arrayForMatrix[i -2]);
				arrayRedY.push(arrayForMatrix[i -1]);
			} 
		}
	}
	
	
	
	$(window).ready(load)

</script>
	
<style>

	body {
		background-color: #ccc; /* grey background*/
	}

	/* Partitions */
	* {
	  box-sizing: border-box;
	}
	
	p.sansserif {
	  font-family: Arial, Helvetica, sans-serif;
	}
	
	/* header for "Machine Learning Playground" */
	header {
		background-color: #666;
		padding: 1px;
		text-align: center;
		color: white;
	}

	/* Partition for graph-article section */
	article {
	  position: relative;
	  float: left;
	  padding: 20px;
	  width: 63%;
	  background-color: #f1f1f1; /* off-white */
	  /*height: 300px; /* only for demonstration, should be removed */
	}

	/* Style the list inside the menu */
	article ul {
	  list-style-type: none;
	  padding: 0;
	}
	
	/* Partition for button navigation section */
	nav {
	  position: relative;
	  float: right;
	  width: 37%;
	  /*height: 300px; /* only for demonstration, should be removed */
	  background: #ccc; /* grey */
	  padding: 20px;
	}
	
	/* Clear floats after the columns */
	section:after {
	  content: "";
	  display: table;
	  clear: both;
	}

	/* Footer for about, etc... */
	footer {
	  background-color: #777;
	  padding: 10px;
	  text-align: center;
	  color: white;
	}

	/* Responsive layout - makes the two columns/boxes stack on top of each other instead of next to each other, on small screens */
	@media (max-width: 600px) {
	  article, nav {
	    width: 100%;
	    height: auto;
	  }
	}
	

/* Interactive graph */
canvas {
	cursor: crosshair;
	background: #E6EBF0;
	/* background: url('http://www.mundoanimalia.com/images/articles/66/58/06/7f6ffaa6bb0b408017b62254211691b5/gallina.jpg'); */
}

/* Buttons */
.button {
  position: relative;
  display: inline-block;
  border-radius: 5px;
  background-color: #02B1E1; /* #45D1E1 original blue */  /* #f4511e orange */ /* #4CAF50 green */
  border: none;
  color: #FFFFFF;
  text-align: center;
  font-size: 13px;
  padding: 9px;
  width: 190px;
  transition: all 0.5s;
  cursor: pointer;
  margin: 8px;
}

.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}

/* Pop-up */
.popup {
  position: relative;
  display: inline-block;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.popup .popuptext {
  visibility: hidden;
  width: 166px;
  background-color: #555;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 8px 0;
  position: absolute;
  z-index: 1;
  bottom: -1050%;
  left: 50%;
  margin-left: -126px;
}

/* Popup arrow */
.popup .popuptext::after {
  content: "";
  position: absolute;
  top: -5%;
  left: 50%;
  margin-left: 22px;
  border-width: 5px;
  border-style: solid;
  border-color: #555 transparent transparent transparent;
}

/* Toggle this class - hide and show the popup */
.popup .show {
  visibility: visible;
  -webkit-animation: fadeIn 1s;
  animation: fadeIn 1s;
}

/* Add animation (fade in the popup) */
@-webkit-keyframes fadeIn {
  from {opacity: 0;} 
  to {opacity: 1;}
}

@keyframes fadeIn {
  from {opacity: 0;}
  to {opacity:1 ;}
}

</style>
</head>

<body>
	<title>Machine Learning Playground</title>
	<header><p class="sansserif"><font size=20> Machine Learning Playground &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp </font><span class="popup" onclick="myFunction()">About
	  <span class="popuptext" id="myPopup">This fun little interactive project is intended to teach those who are interested in machine learning about various popular methods.<br>More to come soon!<br> - Rebecca</span>
	</span></p></header>
	<section>
		
		<article>
			<ul>
				<p class="sansserif"><font size=5>Create a dataset below (<font size=4><i>in <font color="#0ECB48">green</font> by default, or shift-click to <font color="#ff2626">red</font> for binary input</i><font size=5>):</font></p>
				<!--<link rel="stylesheet" href="styles.css">-->
				<button onclick = "resetBtn()" class = "button" style = "vertical-align: middle; background-color: #0aA1c1; width: 140px;"><span>Reset</span></button>
				<canvas id = "canvas" width = "760" height = "400"></canvas> <!-- width="690" height="651" -->
				
				<!-- Result of clicking a button displayed below -->
				<p id="result">
					<pre id="console"></pre> <!-- Display result to screen -->
				</p>
				<br><br>
			</ul>
		</article>
		
		<nav>
			<p class="sansserif"> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i><font face="Albertina" size="5" color="black">. . . then see how various machine <br>&nbsp &nbsp &nbsp learning methods fit your data!</font></i></p>
			
			<!-- Regression -->
			<br>&nbsp &nbsp <i><b><font face="Albertina" size="3" color="black">Regression:</font></i></b><br><button onclick = "linearRegression()" class="button" style="vertical-align: middle; background-color: #77A037;"><span>Linear Regression</span></button><button onclick="kernelRegression()" class="button" style="vertical-align: middle; background-color: #77a037;"><span>Kernel Regression</span></button>
			
			<!-- where dropdown menu could go -->
		<!--	<select>
			  <option value="1">1</option>
			  <option value="2">2</option>
			  <option value="3">3</option>
			  <option value="4">4</option>
			</select>
		 -->
			
			<!-- Discriminative classification -->
			<br><br>&nbsp &nbsp <i><b><font face="Albertina" size="3" color="gray">Discriminative classification:</font></i></b><br><button onclick="kNearest()" class="button" style="vertical-align: middle; background-color: #243F55;"><span><font color="gray">K-Nearest Neighbors</font></span></button><button onclick="kMeans()" class="button" style="vertical-align: middle; background-color: #243f55;"><span><font color="gray">K-means Clustering</font></span></button>

			<button onclick="decisionTrees()" class="button" style="vertical-align: middle; background-color: #065f7c;"><span><font color="gray">Decision Trees</font></span></button><button onclick="randomForest()" class="button" style="vertical-align: middle; background-color: #065f7c;"><span><font color="gray">Random Forest</font></span></button>

			<button onclick="standardSVM()" class="button" style="vertical-align: middle; background-color: #0f7787;"><span><font color="gray">Standard Support Vector Machines</font></span></button><button onclick="multiSVM()" class="button" style="vertical-align: middle; background-color: #0f7787;"><span><font color="gray">Multi-Class Support Vector Machines</font></span></button>

			<button onclick="neuralNetwork()" class="button" style="vertical-align: middle; background-color: #0aA1c1;"><span><font color="gray">Neural Network</font></span></button><button onclick="logisticRegression()" class="button" style="vertical-align: middle; background-color: #0aA1c1;"><span><font color="gray">Logistic Regression</font></span></button>

			<!-- Generative classification -->
			<br><br><i><b>&nbsp &nbsp <font face="Albertina" size="3" color="gray">Generative classification:</font></i></b><br><button onclick="naiveBayes()" class="button" style="vertical-align: middle; background-color: #76496a;"><span><font color="gray">Naive Bayes</font></span></button><button onclick="gaussianMixtureModel()" class="button" style="vertical-align: middle; background-color: #76496a;"><span><font color="gray">Gaussian Mixture Model</font></span></button>
			
		</nav>
	</section>
	<footer>
		
	</footer>
</body>

</html>